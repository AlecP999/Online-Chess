<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chess</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Crimson Pro', serif;
    }

    body {
      background-color: #fafaf9;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      overflow: hidden;
    }

    .game-container {
      max-width: 1400px;
      width: 100%;
      display: grid;
      grid-template-columns: 1fr;
      gap: 2rem;
      animation: fadeIn 0.6s ease-out;
    }

    @media (min-width: 1024px) {
      .game-container {
        grid-template-columns: 2fr 1fr;
      }
    }

    .main-panel {
      background: white;
      border-radius: 2px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      padding: 2rem;
      border: 1px solid #e5e5e5;
    }

    .header {
      margin-bottom: 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .timer-container {
      display: flex;
      gap: 2rem;
      align-items: center;
    }

    .timer {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }

    .timer-label {
      font-size: 0.75rem;
      color: #737373;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .timer-display {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.5rem;
      font-weight: 500;
      color: #171717;
      padding: 0.5rem 1rem;
      background: #f5f5f5;
      border-radius: 4px;
      min-width: 100px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .timer-display.active {
      background: #171717;
      color: white;
      box-shadow: 0 0 0 2px #d97706;
    }

    .timer-display.low {
      background: #dc2626;
      color: white;
      animation: timerPulse 1s ease-in-out infinite;
    }

    @keyframes timerPulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 300;
      letter-spacing: -0.025em;
      color: #171717;
      margin-bottom: 0.25rem;
    }

    .status {
      font-size: 0.875rem;
      color: #737373;
      font-weight: 300;
    }

    .status.checkmate {
      color: #171717;
      font-weight: 400;
    }

    .thinking-indicator {
      display: inline-block;
      margin-left: 0.5rem;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .new-game-btn {
      padding: 0.5rem 1.5rem;
      background: #171717;
      color: white;
      border: none;
      border-radius: 2px;
      font-size: 0.875rem;
      font-weight: 300;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s;
    }

    .new-game-btn:hover {
      background: #404040;
    }

    .board-container {
      display: inline-block;
      border: 2px solid #171717;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .board-row {
      display: flex;
    }

    .chess-square {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .chess-square:hover {
      transform: scale(1.02);
    }

    .chess-square.light {
      background-color: #d4d4d4;
    }

    .chess-square.dark {
      background-color: #92400e;
    }

    .chess-square.selected {
      box-shadow: inset 0 0 0 4px #d97706;
    }

    .chess-piece {
      font-size: 3.75rem;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      cursor: pointer;
      user-select: none;
    }

    .chess-piece:hover {
      transform: scale(1.15) rotate(-5deg);
    }

    .chess-piece.white {
      color: #f5f5f5;
      text-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .chess-piece.black {
      color: #171717;
    }

    .valid-move-indicator {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      animation: pulse 2s ease-in-out infinite;
    }

    .valid-move-dot {
      width: 1rem;
      height: 1rem;
      border-radius: 50%;
      background-color: rgba(239, 68, 68, 0.7);
    }

    .valid-move-capture {
      width: 1rem;
      height: 1rem;
      border: 4px solid #ef4444;
      border-radius: 50%;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .panel {
      background: #d4d4d4;
      border-radius: 2px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
      border: 1px solid #e5e5e5;
    }

    .panel h2 {
      font-size: 1.25rem;
      font-weight: 300;
      margin-bottom: 1rem;
      color: #171717;
      border-bottom: 1px solid #e5e5e5;
      padding-bottom: 0.5rem;
    }

    .captured-section {
      margin-bottom: 1rem;
    }

    .captured-label {
      font-size: 0.75rem;
      color: #737373;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .captured-pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .captured-piece {
      font-size: 1.5rem;
    }

    .captured-piece.white {
      color: #f5f5f5;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .captured-piece.black {
      color: #171717;
    }

    .no-pieces {
      color: #a3a3a3;
      font-size: 0.875rem;
    }

    .move-history {
      max-height: 16rem;
      overflow-y: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
    }

    .move-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0;
      animation: slideIn 0.3s ease-out;
    }

    .move-number {
      color: #a3a3a3;
      width: 2rem;
    }

    .move-piece {
      font-size: 1rem;
    }

    .move-notation {
      color: #737373;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.4;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(-20px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @media (max-width: 640px) {
      .chess-square {
        width: 60px;
        height: 60px;
      }
      .chess-piece {
        font-size: 2.5rem;
      }
    }

    /* Home page styles */
    .home-page {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #171717 0%, #404040 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: transform 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .home-page.hidden {
      transform: translateX(-120%);
      pointer-events: none;
    }

    .home-title {
      font-size: 6rem;
      font-weight: 300;
      color: white;
      margin-bottom: 2rem;
      letter-spacing: -0.05em;
      animation: fadeInScale 1s ease-out;
    }

    .home-subtitle {
      font-size: 1.5rem;
      color: #d4d4d4;
      font-weight: 300;
      margin-bottom: 3rem;
      animation: fadeInScale 1s ease-out 0.2s backwards;
    }

    .home-prompt {
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 1.125rem;
      color: #a3a3a3;
      animation: fadeInScale 1s ease-out 0.4s backwards, pulse 2s ease-in-out 2s infinite;
    }

    .enter-key {
      padding: 0.5rem 1rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      color: white;
      font-size: 0.875rem;
      transition: all 0.3s ease;
    }
    
    .enter-key:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      transform: scale(1.05);
    }

    .mode-button {
      padding: 0.75rem 2rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #d4d4d4;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Crimson Pro', serif;
    }

    .mode-button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .mode-button.active {
      background: white;
      color: #171717;
      border-color: white;
      font-weight: 600;
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .game-container.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="home-page" id="home-page">
    <h1 class="home-title">Chess</h1>
    <p class="home-subtitle">Challenge the AI or Play with a Friend</p>
    
    <div style="text-align: center; margin-bottom: 2rem;">
      <label style="display: block; color: #d4d4d4; font-size: 1.125rem; margin-bottom: 1rem;">Select Game Mode</label>
      <div style="display: flex; gap: 1rem; justify-content: center;">
        <button id="ai-mode-btn" class="mode-button active" onclick="selectMode('ai')">
          vs AI
        </button>
        <button id="pvp-mode-btn" class="mode-button" onclick="selectMode('pvp')">
          Player vs Player
        </button>
      </div>
    </div>
    
    <div id="ai-settings" style="text-align: center; margin-bottom: 3rem;">
      <label style="display: block; color: #d4d4d4; font-size: 1.125rem; margin-bottom: 1rem;">Select AI Difficulty</label>
      <input 
        type="range" 
        id="elo-slider" 
        min="100" 
        max="3000" 
        value="1500" 
        step="100"
        style="width: 300px; height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; outline: none; cursor: pointer;"
      >
      <div style="margin-top: 1rem;">
        <span style="color: white; font-size: 2rem; font-weight: 400;" id="elo-display">1500</span>
        <span style="color: #a3a3a3; font-size: 1rem; display: block; margin-top: 0.5rem;" id="elo-label">Intermediate</span>
      </div>
    </div>
    
    <div id="pvp-settings" style="display: none; text-align: center; margin-bottom: 3rem;">
      <p style="color: #d4d4d4; font-size: 1.125rem;">White vs Black</p>
      <p style="color: #a3a3a3; font-size: 0.875rem; margin-top: 0.5rem;">Take turns on the same device</p>
    </div>
    
    <div class="home-prompt">
      <span>Press</span>
      <span class="enter-key" id="enter-btn" style="cursor: pointer;">ENTER</span>
      <span>to start</span>
    </div>
  </div>

  <div class="game-container hidden" id="game-container">
    <div class="main-panel">
      <div class="header">
        <div>
          <h1>Chess</h1>
          <p class="status" id="status">Your turn</p>
        </div>
        <div class="timer-container">
          <div class="timer">
            <span class="timer-label" id="white-label">Your Time</span>
            <div class="timer-display active" id="white-timer">3:00</div>
          </div>
          <div class="timer">
            <span class="timer-label" id="black-label">AI Time</span>
            <div class="timer-display" id="black-timer">3:00</div>
          </div>
        </div>
        <button class="new-game-btn" onclick="resetGame()">New Game</button>
      </div>
      <div class="board-container" id="board"></div>
    </div>

    <div class="side-panel">
      <div class="panel">
        <h2>Captured Pieces</h2>
        <div class="captured-section">
          <p class="captured-label">You captured</p>
          <div class="captured-pieces" id="captured-white"></div>
        </div>
        <div class="captured-section">
          <p class="captured-label">AI captured</p>
          <div class="captured-pieces" id="captured-black"></div>
        </div>
      </div>

      <div class="panel">
        <h2>Move History</h2>
        <div class="move-history" id="move-history"></div>
      </div>
    </div>
  </div>

  <script>
    let aiElo = 1500;
    let gameMode = 'ai'; // 'ai' or 'pvp'
    
    // Timer variables
    let whiteTime = 180; // 3 minutes in seconds
    let blackTime = 180;
    let timerInterval = null;
    let activeTimer = null; // 'white' or 'black'
    
    const eloLabels = {
      100: 'Complete Beginner',
      200: 'Beginner',
      300: 'Novice',
      400: 'Beginner+',
      500: 'Casual Player',
      600: 'Learning',
      700: 'Amateur',
      800: 'Club Player',
      900: 'Intermediate',
      1000: 'Intermediate+',
      1100: 'Competent',
      1200: 'Club Regular',
      1300: 'Tournament Player',
      1400: 'Strong Club',
      1500: 'Intermediate',
      1600: 'Advanced Club',
      1700: 'Expert',
      1800: 'Advanced',
      1900: 'Strong Expert',
      2000: 'National Master',
      2100: 'FIDE Master',
      2200: 'International Master',
      2300: 'Strong IM',
      2400: 'Grandmaster',
      2500: 'Super GM',
      2600: 'Elite GM',
      2700: 'World Class',
      2800: 'Super Elite',
      2900: 'Magnus Level',
      3000: 'Magnus Carlsen'
    };

    function startTimer(color) {
      stopTimer();
      activeTimer = color;
      updateTimerDisplay();
      
      timerInterval = setInterval(() => {
        if (color === 'white') {
          whiteTime--;
          if (whiteTime <= 0) {
            whiteTime = 0;
            gameStatus = 'timeout-white';
            stopTimer();
            updateStatus();
            updateTimerDisplay();
            return;
          }
        } else {
          blackTime--;
          if (blackTime <= 0) {
            blackTime = 0;
            gameStatus = 'timeout-black';
            stopTimer();
            updateStatus();
            updateTimerDisplay();
            return;
          }
        }
        updateTimerDisplay();
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      activeTimer = null;
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function updateTimerDisplay() {
      const whiteTimerEl = document.getElementById('white-timer');
      const blackTimerEl = document.getElementById('black-timer');
      
      whiteTimerEl.textContent = formatTime(whiteTime);
      blackTimerEl.textContent = formatTime(blackTime);
      
      // Update active state
      whiteTimerEl.className = 'timer-display';
      blackTimerEl.className = 'timer-display';
      
      if (activeTimer === 'white') {
        whiteTimerEl.classList.add('active');
        if (whiteTime <= 30) whiteTimerEl.classList.add('low');
      } else if (activeTimer === 'black') {
        blackTimerEl.classList.add('active');
        if (blackTime <= 30) blackTimerEl.classList.add('low');
      }
    }

    const pieceSymbols = {
      white: { king: '♔', queen: '♕', rook: '♖', bishop: '♗', knight: '♘', pawn: '♙' },
      black: { king: '♚', queen: '♛', rook: '♜', bishop: '♝', knight: '♞', pawn: '♟' }
    };

    let board = [];
    let selectedSquare = null;
    let validMoves = [];
    let currentPlayer = 'white';
    let gameStatus = 'playing';
    let moveHistory = [];
    let capturedPieces = { white: [], black: [] };
    let isThinking = false;
    let castlingRights = {
      white: { kingSide: true, queenSide: true },
      black: { kingSide: true, queenSide: true }
    };

    function initializeBoard() {
      const board = Array(8).fill(null).map(() => Array(8).fill(null));
      
      board[0] = [
        { type: 'rook', color: 'black' }, { type: 'knight', color: 'black' },
        { type: 'bishop', color: 'black' }, { type: 'queen', color: 'black' },
        { type: 'king', color: 'black' }, { type: 'bishop', color: 'black' },
        { type: 'knight', color: 'black' }, { type: 'rook', color: 'black' }
      ];
      board[1] = Array(8).fill(null).map(() => ({ type: 'pawn', color: 'black' }));
      
      board[6] = Array(8).fill(null).map(() => ({ type: 'pawn', color: 'white' }));
      board[7] = [
        { type: 'rook', color: 'white' }, { type: 'knight', color: 'white' },
        { type: 'bishop', color: 'white' }, { type: 'queen', color: 'white' },
        { type: 'king', color: 'white' }, { type: 'bishop', color: 'white' },
        { type: 'knight', color: 'white' }, { type: 'rook', color: 'white' }
      ];
      
      return board;
    }

    function isValidMove(board, fromRow, fromCol, toRow, toCol, piece, checkCastling = true) {
      if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
      
      const targetPiece = board[toRow][toCol];
      if (targetPiece && targetPiece.color === piece.color) return false;

      const rowDiff = toRow - fromRow;
      const colDiff = toCol - fromCol;

      switch (piece.type) {
        case 'pawn':
          const direction = piece.color === 'white' ? -1 : 1;
          const startRow = piece.color === 'white' ? 6 : 1;
          
          if (colDiff === 0) {
            if (rowDiff === direction && !targetPiece) return true;
            if (fromRow === startRow && rowDiff === 2 * direction && !targetPiece && !board[fromRow + direction][fromCol]) return true;
          }
          if (Math.abs(colDiff) === 1 && rowDiff === direction && targetPiece) return true;
          return false;

        case 'rook':
          if (rowDiff === 0 || colDiff === 0) {
            return isPathClear(board, fromRow, fromCol, toRow, toCol);
          }
          return false;

        case 'knight':
          return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) ||
                 (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);

        case 'bishop':
          if (Math.abs(rowDiff) === Math.abs(colDiff)) {
            return isPathClear(board, fromRow, fromCol, toRow, toCol);
          }
          return false;

        case 'queen':
          if (rowDiff === 0 || colDiff === 0 || Math.abs(rowDiff) === Math.abs(colDiff)) {
            return isPathClear(board, fromRow, fromCol, toRow, toCol);
          }
          return false;

        case 'king':
          if (Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1) return true;
          
          if (checkCastling && rowDiff === 0 && Math.abs(colDiff) === 2) {
            return canCastle(board, fromRow, fromCol, toCol > fromCol ? 'king' : 'queen', piece.color);
          }
          return false;

        default:
          return false;
      }
    }

    function canCastle(board, kingRow, kingCol, side, color) {
      const rights = castlingRights[color];
      const row = color === 'white' ? 7 : 0;
      
      if (side === 'king' && !rights.kingSide) return false;
      if (side === 'queen' && !rights.queenSide) return false;
      
      if (isKingInCheck(board, color)) return false;
      
      if (side === 'king') {
        const rookCol = 7;
        if (board[row][5] !== null || board[row][6] !== null) return false;
        for (let col = kingCol; col <= 6; col++) {
          if (isSquareUnderAttack(board, row, col, color)) return false;
        }
        if (!board[row][rookCol] || board[row][rookCol].type !== 'rook' || board[row][rookCol].color !== color) return false;
        return true;
      } else {
        const rookCol = 0;
        if (board[row][1] !== null || board[row][2] !== null || board[row][3] !== null) return false;
        for (let col = kingCol; col >= 2; col--) {
          if (isSquareUnderAttack(board, row, col, color)) return false;
        }
        if (!board[row][rookCol] || board[row][rookCol].type !== 'rook' || board[row][rookCol].color !== color) return false;
        return true;
      }
    }

    function isSquareUnderAttack(board, row, col, color) {
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.color !== color) {
            if (isValidMove(board, i, j, row, col, piece, false)) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function isPathClear(board, fromRow, fromCol, toRow, toCol) {
      const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
      const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
      
      let currentRow = fromRow + rowStep;
      let currentCol = fromCol + colStep;
      
      while (currentRow !== toRow || currentCol !== toCol) {
        if (board[currentRow][currentCol] !== null) return false;
        currentRow += rowStep;
        currentCol += colStep;
      }
      
      return true;
    }

    function getValidMoves(board, row, col) {
      const piece = board[row][col];
      if (!piece) return [];
      
      const moves = [];
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (isValidMove(board, row, col, i, j, piece)) {
            moves.push({ row: i, col: j });
          }
        }
      }
      return moves;
    }

    function isKingInCheck(board, color) {
      let kingPos = null;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (board[i][j]?.type === 'king' && board[i][j]?.color === color) {
            kingPos = { row: i, col: j };
            break;
          }
        }
        if (kingPos) break;
      }
      
      if (!kingPos) return false;
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.color !== color) {
            if (isValidMove(board, i, j, kingPos.row, kingPos.col, piece)) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function hasValidMoves(board, color) {
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.color === color) {
            const moves = getValidMoves(board, i, j);
            for (const move of moves) {
              const testBoard = board.map(row => [...row]);
              testBoard[move.row][move.col] = testBoard[i][j];
              testBoard[i][j] = null;
              if (!isKingInCheck(testBoard, color)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }

    function handleSquareClick(row, col) {
      if (gameStatus !== 'playing' || isThinking) return;
      
      // In AI mode, only allow white to move
      if (gameMode === 'ai' && currentPlayer === 'black') return;

      // Start timer on first move
      if (moveHistory.length === 0 && !timerInterval) {
        startTimer('white');
      }

      if (selectedSquare) {
        const move = validMoves.find(m => m.row === row && m.col === col);
        if (move) {
          makeMove(selectedSquare.row, selectedSquare.col, row, col);
        }
        selectedSquare = null;
        validMoves = [];
        renderBoard();
      } else {
        const piece = board[row][col];
        if (piece && piece.color === currentPlayer) {
          selectedSquare = { row, col };
          validMoves = getValidMoves(board, row, col).filter(move => {
            const testBoard = board.map(r => [...r]);
            testBoard[move.row][move.col] = testBoard[row][col];
            testBoard[row][col] = null;
            return !isKingInCheck(testBoard, currentPlayer);
          });
          renderBoard();
        }
      }
    }

    function makeMove(fromRow, fromCol, toRow, toCol) {
      const piece = board[fromRow][fromCol];
      const capturedPiece = board[toRow][toCol];
      
      if (capturedPiece) {
        capturedPieces[piece.color].push(capturedPiece);
      }
      
      if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
        const row = piece.color === 'white' ? 7 : 0;
        if (toCol > fromCol) {
          board[row][5] = board[row][7];
          board[row][7] = null;
        } else {
          board[row][3] = board[row][0];
          board[row][0] = null;
        }
      }
      
      board[toRow][toCol] = piece;
      board[fromRow][fromCol] = null;
      
      if (piece.type === 'king') {
        castlingRights[piece.color].kingSide = false;
        castlingRights[piece.color].queenSide = false;
      } else if (piece.type === 'rook') {
        const row = piece.color === 'white' ? 7 : 0;
        if (fromRow === row && fromCol === 0) {
          castlingRights[piece.color].queenSide = false;
        } else if (fromRow === row && fromCol === 7) {
          castlingRights[piece.color].kingSide = false;
        }
      }
      
      if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
        board[toRow][toCol] = { type: 'queen', color: piece.color };
      }
      
      moveHistory.push({ from: [fromRow, fromCol], to: [toRow, toCol], piece });
      
      const nextPlayer = currentPlayer === 'white' ? 'black' : 'white';
      
      if (isKingInCheck(board, nextPlayer)) {
        if (!hasValidMoves(board, nextPlayer)) {
          gameStatus = `checkmate-${currentPlayer}`;
          stopTimer();
          updateStatus();
          renderAll();
          return;
        }
      } else if (!hasValidMoves(board, nextPlayer)) {
        gameStatus = 'stalemate';
        stopTimer();
        updateStatus();
        renderAll();
        return;
      }
      
      currentPlayer = nextPlayer;
      
      // Switch timer
      startTimer(nextPlayer);
      
      updateStatus();
      renderAll();
      
      if (gameMode === 'ai' && currentPlayer === 'black' && gameStatus === 'playing') {
        isThinking = true;
        updateStatus();
        // AI thinking time scales with ELO
        // 100 ELO: 500ms, 1500 ELO: 1500ms, 3000 ELO: 3000ms
        const thinkingTime = Math.max(500, Math.min(3000, aiElo));
        setTimeout(makeAIMove, thinkingTime);
      }
    }

    function makeAIMove() {
      const allMoves = [];
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.color === 'black') {
            const moves = getValidMoves(board, i, j);
            for (const move of moves) {
              const testBoard = board.map(r => [...r]);
              testBoard[move.row][move.col] = testBoard[i][j];
              testBoard[i][j] = null;
              if (!isKingInCheck(testBoard, 'black')) {
                allMoves.push({ from: { row: i, col: j }, to: move });
              }
            }
          }
        }
      }

      if (allMoves.length > 0) {
        // ELO-based difficulty
        const skill = (aiElo - 100) / 2900; // 0 to 1
        
        const scoredMoves = allMoves.map(move => {
          const testBoard = board.map(r => [...r]);
          const piece = testBoard[move.from.row][move.from.col];
          if (!piece) return { move, score: 0 }; // Safety check
          
          const capturedPiece = testBoard[move.to.row][move.to.col];
          testBoard[move.to.row][move.to.col] = piece;
          testBoard[move.from.row][move.from.col] = null;
          
          let score = 0;
          
          // Piece values
          const pieceValues = { pawn: 1, knight: 3, bishop: 3.2, rook: 5, queen: 9, king: 0 };
          
          // Material evaluation - capture value
          if (capturedPiece) {
            const capturedType = capturedPiece.type;
            if (capturedType && pieceValues[capturedType]) {
              score += pieceValues[capturedType] * 100;
            }
          }
          
          // Check if move puts opponent in check
          if (isKingInCheck(testBoard, 'white')) {
            score += 50 * skill;
          }
          
          // Positional scoring (higher ELO = better positional play)
          if (aiElo >= 800) {
            // Center control
            const centerSquares = [[3,3],[3,4],[4,3],[4,4]];
            if (centerSquares.some(s => s[0] === move.to.row && s[1] === move.to.col)) {
              score += 20 * skill;
            }
            
            // Piece development (early game)
            if (moveHistory.length < 10) {
              if (piece.type && (piece.type === 'knight' || piece.type === 'bishop')) {
                if (move.from.row === 0) score += 15 * skill;
              }
            }
          }
          
          // Advanced tactics (1500+)
          if (aiElo >= 1500) {
            // Protect valuable pieces
            let protectedScore = 0;
            for (let i = 0; i < 8; i++) {
              for (let j = 0; j < 8; j++) {
                const ally = testBoard[i][j];
                if (ally && ally.color === 'black' && ally.type && isValidMove(testBoard, move.to.row, move.to.col, i, j, piece, false)) {
                  protectedScore += pieceValues[ally.type] * 5;
                }
              }
            }
            score += protectedScore * skill;
            
            // Avoid hanging pieces
            if (piece.type && isSquareUnderAttack(testBoard, move.to.row, move.to.col, 'black')) {
              score -= pieceValues[piece.type] * 30 * skill;
            }
          }
          
          // Master level (2000+)
          if (aiElo >= 2000) {
            // King safety
            let kingPos = null;
            for (let i = 0; i < 8; i++) {
              for (let j = 0; j < 8; j++) {
                if (testBoard[i][j]?.type === 'king' && testBoard[i][j]?.color === 'black') {
                  kingPos = { row: i, col: j };
                  break;
                }
              }
              if (kingPos) break;
            }
            
            if (kingPos) {
              // Penalize exposed king
              const kingExposure = getAttacksOnSquare(testBoard, kingPos.row, kingPos.col, 'black');
              score -= kingExposure * 15 * skill;
            }
            
            // Checkmate threats
            if (canDeliverCheckmate(testBoard, move)) {
              score += 1000;
            }
          }
          
          // Grandmaster level (2400+)
          if (aiElo >= 2400) {
            // Evaluate pawn structure
            score += evaluatePawnStructure(testBoard, 'black') * skill;
            
            // Piece coordination
            score += evaluatePieceCoordination(testBoard, 'black') * skill;
          }
          
          // Magnus Carlsen level (2900+)
          if (aiElo >= 2900) {
            // Deep endgame knowledge - Magnus excels in endgames
            const totalPieces = testBoard.flat().filter(p => p !== null).length;
            if (totalPieces <= 10) {
              score += evaluateEndgame(testBoard, 'black') * 3;
            }
            
            // Perfect tactics with deep calculation
            score += evaluateTacticalSharpness(testBoard, move) * 2.5;
            
            // Long-term strategic planning
            score += evaluateLongTermStrategy(testBoard, move, 'black') * 1.5;
            
            // Prophylactic thinking - prevent opponent's plans
            score += evaluateProhylaxis(testBoard, move, 'black') * 2;
            
            // Squeeze opponent with positional pressure
            score += evaluatePositionalPressure(testBoard, 'black') * 1.8;
            
            // Near-perfect opening and middlegame play
            if (moveHistory.length < 15) {
              score += evaluateOpeningPrinciples(testBoard, 'black') * 2;
            }
            
            // Minimize risk of errors - Magnus rarely blunders
            const moveRisk = evaluateMoveRisk(testBoard, move, 'black');
            score -= moveRisk * 3;
          }
          
          // Random factor decreases with ELO - Magnus has almost no randomness
          const randomFactor = aiElo >= 2900 ? (1 - skill) * 5 : (1 - skill) * 50;
          score += Math.random() * randomFactor;
          
          return { move, score };
        });
        
        scoredMoves.sort((a, b) => b.score - a.score);
        
        // Lower ELO sometimes makes mistakes
        const mistakeChance = 1 - skill;
        let selectedMove;
        
        // Magnus level (2900+) makes almost zero mistakes
        if (aiElo >= 2900) {
          // 95% chance to pick absolute best move, 5% chance to pick from top 3
          if (Math.random() < 0.95) {
            selectedMove = scoredMoves[0].move;
          } else {
            const topMoves = scoredMoves.slice(0, Math.min(3, scoredMoves.length));
            selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)].move;
          }
        } else if (Math.random() < mistakeChance && scoredMoves.length > 3) {
          // Pick a random move from top 30% for lower ELO
          const topMoves = scoredMoves.slice(0, Math.max(3, Math.floor(scoredMoves.length * 0.3)));
          selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)].move;
        } else {
          // Pick best move
          selectedMove = scoredMoves[0].move;
        }
        
        makeMove(selectedMove.from.row, selectedMove.from.col, selectedMove.to.row, selectedMove.to.col);
      }
      
      isThinking = false;
      updateStatus();
    }
    
    function getAttacksOnSquare(board, row, col, color) {
      let attacks = 0;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.color !== color) {
            if (isValidMove(board, i, j, row, col, piece, false)) {
              attacks++;
            }
          }
        }
      }
      return attacks;
    }
    
    function canDeliverCheckmate(board, move) {
      const testBoard = board.map(r => [...r]);
      testBoard[move.to.row][move.to.col] = testBoard[move.from.row][move.from.col];
      testBoard[move.from.row][move.from.col] = null;
      
      if (isKingInCheck(testBoard, 'white') && !hasValidMoves(testBoard, 'white')) {
        return true;
      }
      return false;
    }
    
    function evaluatePawnStructure(board, color) {
      let score = 0;
      const pawns = [];
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.type === 'pawn' && piece.color === color) {
            pawns.push({ row: i, col: j });
          }
        }
      }
      
      // Penalize doubled pawns
      const columns = pawns.map(p => p.col);
      const doubled = columns.length - new Set(columns).size;
      score -= doubled * 10;
      
      // Reward passed pawns
      pawns.forEach(pawn => {
        let isPassed = true;
        const direction = color === 'white' ? -1 : 1;
        for (let row = pawn.row + direction; color === 'white' ? row >= 0 : row < 8; row += direction) {
          for (let col = Math.max(0, pawn.col - 1); col <= Math.min(7, pawn.col + 1); col++) {
            const piece = board[row][col];
            if (piece && piece.type === 'pawn' && piece.color !== color) {
              isPassed = false;
            }
          }
        }
        if (isPassed) score += 20;
      });
      
      return score;
    }
    
    function evaluatePieceCoordination(board, color) {
      let score = 0;
      const pieces = [];
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (board[i][j] && board[i][j].color === color) {
            pieces.push({ row: i, col: j, piece: board[i][j] });
          }
        }
      }
      
      // Reward pieces that protect each other
      pieces.forEach(p1 => {
        pieces.forEach(p2 => {
          if (p1 !== p2 && isValidMove(board, p1.row, p1.col, p2.row, p2.col, p1.piece, false)) {
            score += 5;
          }
        });
      });
      
      return score;
    }
    
    function evaluateEndgame(board, color) {
      let score = 0;
      
      // In endgame, centralize king
      let kingPos = null;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (board[i][j]?.type === 'king' && board[i][j]?.color === color) {
            kingPos = { row: i, col: j };
            break;
          }
        }
        if (kingPos) break;
      }
      
      if (kingPos) {
        const centerDistance = Math.abs(kingPos.row - 3.5) + Math.abs(kingPos.col - 3.5);
        score -= centerDistance * 5;
      }
      
      return score;
    }
    
    function evaluateTacticalSharpness(board, move) {
      let score = 0;
      
      // Look for tactical motifs
      const testBoard = board.map(r => [...r]);
      testBoard[move.to.row][move.to.col] = testBoard[move.from.row][move.from.col];
      testBoard[move.from.row][move.from.col] = null;
      
      // Fork detection
      const piece = testBoard[move.to.row][move.to.col];
      if (!piece) return score;
      
      let attackedPieces = 0;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const target = testBoard[i][j];
          if (target && target.color !== piece.color && isValidMove(testBoard, move.to.row, move.to.col, i, j, piece, false)) {
            attackedPieces++;
          }
        }
      }
      if (attackedPieces >= 2) score += 30;
      
      return score;
    }
    
    function evaluateLongTermStrategy(board, move, color) {
      let score = 0;
      
      const testBoard = board.map(r => [...r]);
      testBoard[move.to.row][move.to.col] = testBoard[move.from.row][move.from.col];
      testBoard[move.from.row][move.from.col] = null;
      
      // Control of key squares
      const keySquares = [[3,3],[3,4],[4,3],[4,4],[2,3],[2,4],[5,3],[5,4]];
      keySquares.forEach(sq => {
        if (isSquareUnderAttack(testBoard, sq[0], sq[1], color === 'white' ? 'black' : 'white') &&
            !isSquareUnderAttack(testBoard, sq[0], sq[1], color)) {
          score += 15;
        }
      });
      
      // Space advantage
      let spaceControl = 0;
      const attackZone = color === 'black' ? [4, 5, 6, 7] : [0, 1, 2, 3];
      attackZone.forEach(row => {
        for (let col = 0; col < 8; col++) {
          if (isSquareUnderAttack(testBoard, row, col, color === 'white' ? 'black' : 'white')) {
            spaceControl++;
          }
        }
      });
      score += spaceControl * 2;
      
      return score;
    }
    
    function evaluateProhylaxis(board, move, color) {
      let score = 0;
      
      const testBoard = board.map(r => [...r]);
      testBoard[move.to.row][move.to.col] = testBoard[move.from.row][move.from.col];
      testBoard[move.from.row][move.from.col] = null;
      
      const opponentColor = color === 'white' ? 'black' : 'white';
      
      // Count opponent's threats before and after move
      let threatsBefore = 0;
      let threatsAfter = 0;
      
      // Threats before move
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.color === opponentColor) {
            const moves = getValidMoves(board, i, j);
            moves.forEach(m => {
              const target = board[m.row][m.col];
              if (target && target.color === color) {
                threatsBefore++;
              }
            });
          }
        }
      }
      
      // Threats after move
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = testBoard[i][j];
          if (piece && piece.color === opponentColor) {
            const moves = getValidMoves(testBoard, i, j);
            moves.forEach(m => {
              const target = testBoard[m.row][m.col];
              if (target && target.color === color) {
                threatsAfter++;
              }
            });
          }
        }
      }
      
      // Reward moves that reduce opponent threats
      score += (threatsBefore - threatsAfter) * 8;
      
      return score;
    }
    
    function evaluatePositionalPressure(board, color) {
      let score = 0;
      
      // Restrict opponent pieces
      const opponentColor = color === 'white' ? 'black' : 'white';
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.color === opponentColor) {
            const mobility = getValidMoves(board, i, j).length;
            // Reward restricting opponent mobility
            score += (10 - mobility) * 2;
          }
        }
      }
      
      return score;
    }
    
    function evaluateOpeningPrinciples(board, color) {
      let score = 0;
      
      // Reward piece development
      const backRank = color === 'white' ? 7 : 0;
      const knightStartCols = [1, 6];
      const bishopStartCols = [2, 5];
      
      knightStartCols.forEach(col => {
        const piece = board[backRank][col];
        if (!piece || piece.type !== 'knight') {
          score += 15;
        }
      });
      
      bishopStartCols.forEach(col => {
        const piece = board[backRank][col];
        if (!piece || piece.type !== 'bishop') {
          score += 15;
        }
      });
      
      // Control center with pawns
      const centerPawnRows = color === 'white' ? [4, 5] : [2, 3];
      const centerCols = [3, 4];
      
      centerPawnRows.forEach(row => {
        centerCols.forEach(col => {
          const piece = board[row][col];
          if (piece && piece.type === 'pawn' && piece.color === color) {
            score += 20;
          }
        });
      });
      
      // King safety (castled or can castle)
      if (castlingRights[color].kingSide || castlingRights[color].queenSide) {
        score += 10;
      }
      
      return score;
    }
    
    function evaluateMoveRisk(board, move, color) {
      let risk = 0;
      
      const testBoard = board.map(r => [...r]);
      const piece = testBoard[move.from.row][move.from.col];
      if (!piece || !piece.type) return 0; // Safety check
      
      testBoard[move.to.row][move.to.col] = piece;
      testBoard[move.from.row][move.from.col] = null;
      
      // Check if move hangs a piece
      if (isSquareUnderAttack(testBoard, move.to.row, move.to.col, color)) {
        const pieceValues = { pawn: 1, knight: 3, bishop: 3.2, rook: 5, queen: 9, king: 0 };
        
        // Check if square is defended
        let defenders = 0;
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            const ally = testBoard[i][j];
            if (ally && ally.color === color && isValidMove(testBoard, i, j, move.to.row, move.to.col, ally, false)) {
              defenders++;
            }
          }
        }
        
        let attackers = 0;
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            const enemy = testBoard[i][j];
            if (enemy && enemy.color !== color && isValidMove(testBoard, i, j, move.to.row, move.to.col, enemy, false)) {
              attackers++;
            }
          }
        }
        
        if (attackers > defenders) {
          risk += pieceValues[piece.type] * 20;
        }
      }
      
      // Check if move weakens king safety
      if (piece.type === 'pawn') {
        let kingPos = null;
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (testBoard[i][j]?.type === 'king' && testBoard[i][j]?.color === color) {
              kingPos = { row: i, col: j };
              break;
            }
          }
          if (kingPos) break;
        }
        
        if (kingPos && Math.abs(move.from.col - kingPos.col) <= 2) {
          risk += 15;
        }
      }
      
      return risk;
    }

    function updateStatus() {
      const statusEl = document.getElementById('status');
      if (gameStatus === 'playing') {
        if (gameMode === 'pvp') {
          statusEl.textContent = currentPlayer === 'white' ? 'White to move' : 'Black to move';
          statusEl.className = 'status';
        } else {
          if (currentPlayer === 'white') {
            statusEl.textContent = 'Your turn';
            statusEl.className = 'status';
          } else {
            statusEl.innerHTML = 'AI thinking...<span class="thinking-indicator">●</span>';
            statusEl.className = 'status';
          }
        }
      } else if (gameStatus.startsWith('checkmate')) {
        if (gameMode === 'pvp') {
          statusEl.textContent = `Checkmate — ${gameStatus.includes('white') ? 'White wins' : 'Black wins'}`;
        } else {
          statusEl.textContent = `Checkmate — ${gameStatus.includes('white') ? 'You win' : 'AI wins'}`;
        }
        statusEl.className = 'status checkmate';
      } else if (gameStatus.startsWith('timeout')) {
        if (gameMode === 'pvp') {
          statusEl.textContent = `Time out — ${gameStatus.includes('white') ? 'Black wins' : 'White wins'}`;
        } else {
          statusEl.textContent = `Time out — ${gameStatus.includes('white') ? 'AI wins' : 'You win'}`;
        }
        statusEl.className = 'status checkmate';
      } else {
        statusEl.textContent = 'Stalemate — Draw';
        statusEl.className = 'status checkmate';
      }
    }

    function renderBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      
      for (let row = 0; row < 8; row++) {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'board-row';
        
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          const isLight = (row + col) % 2 === 0;
          square.className = `chess-square ${isLight ? 'light' : 'dark'}`;
          
          if (selectedSquare?.row === row && selectedSquare?.col === col) {
            square.classList.add('selected');
          }
          
          const piece = board[row][col];
          if (piece) {
            const pieceSpan = document.createElement('span');
            pieceSpan.className = `chess-piece ${piece.color}`;
            pieceSpan.textContent = pieceSymbols[piece.color][piece.type];
            square.appendChild(pieceSpan);
          }
          
          const isValidMove = validMoves.some(m => m.row === row && m.col === col);
          if (isValidMove) {
            const indicator = document.createElement('div');
            indicator.className = 'valid-move-indicator';
            const dot = document.createElement('div');
            dot.className = piece ? 'valid-move-capture' : 'valid-move-dot';
            indicator.appendChild(dot);
            square.appendChild(indicator);
          }
          
          square.onclick = () => handleSquareClick(row, col);
          rowDiv.appendChild(square);
        }
        
        boardEl.appendChild(rowDiv);
      }
    }

    function renderCapturedPieces() {
      const whiteEl = document.getElementById('captured-white');
      const blackEl = document.getElementById('captured-black');
      
      whiteEl.innerHTML = capturedPieces.white.length === 0 
        ? '<span class="no-pieces">None yet</span>'
        : capturedPieces.white.map(p => 
            `<span class="captured-piece black">${pieceSymbols.black[p.type]}</span>`
          ).join('');
      
      blackEl.innerHTML = capturedPieces.black.length === 0
        ? '<span class="no-pieces">None yet</span>'
        : capturedPieces.black.map(p => 
            `<span class="captured-piece white">${pieceSymbols.white[p.type]}</span>`
          ).join('');
    }

    function renderMoveHistory() {
      const historyEl = document.getElementById('move-history');
      
      if (moveHistory.length === 0) {
        historyEl.innerHTML = '<span class="no-pieces">No moves yet</span>';
      } else {
        historyEl.innerHTML = moveHistory.map((move, i) => {
          const fromCol = String.fromCharCode(97 + move.from[1]);
          const fromRow = 8 - move.from[0];
          const toCol = String.fromCharCode(97 + move.to[1]);
          const toRow = 8 - move.to[0];
          const colorClass = move.piece.color === 'white' ? 'black' : '';
          
          return `
            <div class="move-item">
              <span class="move-number">${i + 1}.</span>
              <span class="move-piece ${colorClass}">${pieceSymbols[move.piece.color][move.piece.type]}</span>
              <span class="move-notation">${fromCol}${fromRow} → ${toCol}${toRow}</span>
            </div>
          `;
        }).join('');
      }
    }

    function renderAll() {
      renderBoard();
      renderCapturedPieces();
      renderMoveHistory();
    }

    function resetGame() {
      // Return to home page
      const homePage = document.getElementById('home-page');
      const gameContainer = document.getElementById('game-container');
      
      homePage.classList.remove('hidden');
      gameContainer.classList.add('hidden');
      
      // Reset game state
      board = initializeBoard();
      selectedSquare = null;
      validMoves = [];
      currentPlayer = 'white';
      gameStatus = 'playing';
      moveHistory = [];
      capturedPieces = { white: [], black: [] };
      isThinking = false;
      castlingRights = {
        white: { kingSide: true, queenSide: true },
        black: { kingSide: true, queenSide: true }
      };
      
      // Reset timers
      stopTimer();
      whiteTime = 180;
      blackTime = 180;
      updateTimerDisplay();
      
      updateStatus();
      renderAll();
    }

    // Initialize game
    board = initializeBoard();
    updateStatus();
    renderAll();
    
    // Home page ELO slider
    const eloSlider = document.getElementById('elo-slider');
    const eloDisplay = document.getElementById('elo-display');
    const eloLabel = document.getElementById('elo-label');
    
    eloSlider.addEventListener('input', (e) => {
      const elo = parseInt(e.target.value);
      eloDisplay.textContent = elo;
      eloLabel.textContent = eloLabels[elo];
      aiElo = elo;
    });
    
    // Mode selection
    function selectMode(mode) {
      gameMode = mode;
      const aiBtn = document.getElementById('ai-mode-btn');
      const pvpBtn = document.getElementById('pvp-mode-btn');
      const aiSettings = document.getElementById('ai-settings');
      const pvpSettings = document.getElementById('pvp-settings');
      
      if (mode === 'ai') {
        aiBtn.classList.add('active');
        pvpBtn.classList.remove('active');
        aiSettings.style.display = 'block';
        pvpSettings.style.display = 'none';
      } else {
        pvpBtn.classList.add('active');
        aiBtn.classList.remove('active');
        aiSettings.style.display = 'none';
        pvpSettings.style.display = 'block';
      }
    }
    
    // Update timer labels based on mode
    function updateTimerLabels() {
      const whiteLabel = document.getElementById('white-label');
      const blackLabel = document.getElementById('black-label');
      
      if (gameMode === 'pvp') {
        whiteLabel.textContent = 'White Time';
        blackLabel.textContent = 'Black Time';
      } else {
        whiteLabel.textContent = 'Your Time';
        blackLabel.textContent = 'AI Time';
      }
    }
    
    // Enter key to start game
    function startGame() {
      const homePage = document.getElementById('home-page');
      const gameContainer = document.getElementById('game-container');
      
      if (!homePage.classList.contains('hidden')) {
        homePage.classList.add('hidden');
        gameContainer.classList.remove('hidden');
        updateTimerLabels();
        updateStatus();
      }
    }
    
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        startGame();
      }
    });
    
    // Click on enter button to start
    document.getElementById('enter-btn').addEventListener('click', startGame);
  </script>
</body>
</html>
